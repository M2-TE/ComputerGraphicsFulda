<!doctype html>
<html lang="en">

<body>
    <canvas id="c" width="400" height="400">
</body>

</html>

<script src="Shaders/Default.vert"></script>
<script src="Shaders/Default.frag"></script>

<script src="Shaders/Textured.vert"></script>
<script src="Shaders/Textured.frag"></script>

<script src="js/Math.js"></script>
<script src="js/GlWrappers.js"></script>
<script src="js/GameObjects.js"></script>
<script src="js/Components.js"></script>

<script>
    function loadTexture(gl) {
        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);

        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA,
            gl.UNSIGNED_BYTE, new Uint8Array([100, 100, 100, 255]));

        var image = new Image();
        image.onload = function () {
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

            function isPowerOf2(value) {
                return (value & (value - 1)) == 0;
            }

            if (isPowerOf2(image.width) && isPowerOf2(image.height)) {
                gl.generateMipmap(gl.TEXTURE_2D);
            } else {
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            }
        }
        image.src = "Textures/ClockFace.png";

        return texture;
    }

    function init() {
        var canvas = document.getElementById('c');
        gl = canvas.getContext('webgl', { alpha: true, depth: true });

        var clockTex = loadTexture(gl);

        camera = new Camera(gl, 60, 0.001, 1000);
        camera.transform.position.z = 4;

        // shader program
        var shaderProgram = new ShaderProgram(gl, defaultVS, defaultFS);
        var texShaderProgram = new ShaderProgram(gl, texturedVS, texturedFS);

        // depth
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.DEPTH_TEST);
        gl.clearDepth(1.0);
        gl.depthMask(true);

        // color
        gl.clearColor(0.3, 0.7, 0.3, 1.0);
        gl.colorMask(true, true, true, true);

        // viewport
        gl.viewport(0, 0, canvas.width, canvas.height);

        // transparency
        gl.enable(gl.BLEND)
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        c.setAttribute("tabindex", "0");
        canvas.addEventListener('keypress', function (evt) {
            switch (evt.charCode) {
                case 43: /* + */ camera.transform.position.z -= deltaTime; break;
                case 45: /* - */ camera.transform.position.z += deltaTime; break;
            }
        }, true);
        c.addEventListener('keydown', function (evt) {
            switch (evt.keyCode) {
                case 37: /* left */ camera.transform.position.x -= deltaTime; break;
                case 38: /* up */ camera.transform.position.y += deltaTime; break;
                case 39: /* right */ camera.transform.position.x += deltaTime; break;
                case 40: /* down */ camera.transform.position.y -= deltaTime; break;
            }
        }, true);

        // game objects
        gameObjects = [];
        /* 
        * currently using a per-object-buffer setup
        * with static_draw buffer usage. Depending on future tasks,
        * this can be changed to creating 3 global buffers for pos, col and indices
        * which each object uploads its data to on every draw call
        * -> dynamic buffer usage
        */

        // unit values
        const unit = 0.5;
        const pnit = -0.5;

        // cube vert data
        var cubeVerts = [
            pnit, unit, unit,
            unit, unit, unit,
            pnit, unit, pnit,
            unit, unit, pnit,
            pnit, pnit, unit,
            unit, pnit, unit,
            pnit, pnit, pnit,
            unit, pnit, pnit];
        var cubeCols = [
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2,
            1.0, 0.2, 0.2];
        var cubeIndices = [
            0, 1, 2, 1, 3, 2, // top
            4, 6, 5, 6, 7, 5, // bot
            2, 3, 6, 3, 7, 6, // fwd
            1, 0, 5, 0, 4, 5, // bwd
            3, 1, 7, 1, 5, 7, // right
            0, 2, 4, 2, 6, 4];// left

        // sphere vert data
        var sphereVerts = [];
        var sphereCols = [];
        var sphereIndices = [];
        const nLong = 8, nLati = 8;
        const nLongP = nLong + 1, nLatiP = nLati + 1;
        for (var lati = 0; lati < nLatiP; ++lati) {
            for (var long = 0; long < nLongP; ++long) {
                const x = Math.sin(Math.PI * lati / nLati) * Math.cos(2 * Math.PI * long / nLong)
                const y = Math.sin(Math.PI * lati / nLati) * Math.sin(2 * Math.PI * long / nLong);
                const z = Math.cos(Math.PI * lati / nLati);
                sphereVerts.push(x, y, z);
                sphereCols.push(1.0, 0.2, 0.2);
            }
        }
        for (var lati = 0; lati < nLati; ++lati) {
            for (var long = 0; long < nLong; ++long) {
                const latiIndex = lati * nLatiP
                const latiIndexP = (lati + 1) * nLatiP;
                const longIndex = long;
                const longIndexP = long + 1;
                sphereIndices.push(
                    latiIndex + longIndex, latiIndex + longIndexP, latiIndexP + longIndex,
                    latiIndex + longIndexP, latiIndexP + longIndexP, latiIndexP + longIndex);
            }
        }

        // cube
        {
            var go = gameObjects[gameObjects.push(new ColGameObject(gl, shaderProgram)) - 1];
            go.AssignVerts(cubeVerts, cubeCols, cubeIndices);
            go.transform.position = new Vec3(1.0, 1.0, 0.0);
            go.transform.rotEuler = new Vec3(1.0, 0.0, 0.0);
        }

        // sphere
        {
            var go = gameObjects[gameObjects.push(new ColGameObject(gl, shaderProgram)) - 1];
            go.AssignVerts(sphereVerts, sphereCols, sphereIndices);
            go.transform.position = new Vec3(-1.0, 1.0, 0.0);
            go.transform.rotEuler = new Vec3(0.0, 0.0, 0.0);
        }
    };

    function update() {
        gameObjects[0].transform.rotEuler.y += deltaTime;
        // gameObjects[1].transform.rotEuler.y += deltaTime;
    };

    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        const drawMode = this.gl.TRIANGLES;
        //const drawMode = this.gl.LINES;
        for (var i = 0; i < gameObjects.length; ++i) {
            gameObjects[i].Draw(camera, drawMode);
        }
    };

    function shutdown() {
        {
            // release resources
            for (var i = 0; i < gameObjects.length; ++i) {
                gameObjects[i].Destroy();
            }
            shaderProgram.Destroy();
        }
    };

    var totalTime;
    var deltaTime;
    main();
    function main() {
        var gl;
        var gameObjects;
        var camera;

        init();

        var lastFrameTimestamp = 0;
        deltaTime = 0;

        // initiate frame pass loop
        renderLoop(0);
        function renderLoop(time) {
            totalTime = time;
            deltaTime = (time *= 0.001) - lastFrameTimestamp;
            lastFrameTimestamp = time;
            var framerate = 1.0 / deltaTime;

            //console.log(framerate);
            //console.log(deltaTime);

            update();
            render();
            requestAnimationFrame(renderLoop);
        };

        // shutdown();
    };
</script>