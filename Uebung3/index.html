<!doctype html>
<html lang="en">

<body>
    <canvas id="c" width="400" height="400"></canvas>
</body>

</html>

<script id="vertexShader" type="notjs">
    attribute vec4 pos;
    attribute vec3 color;
    varying vec3 vColor;
    void main() {
        vColor = color;
        gl_Position = vec4(pos);
    }
   
</script>

<script id="fragmentShader" type="notjs">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision	highp float;
    #else
        precision	mediump float;
    #endif

    varying vec3 vColor;
    void main() {
        gl_FragColor = vec4(vColor, 1.0);
    }
   
</script>

<script>
    var canvas = document.getElementById('c');
    var gl = canvas.getContext('webgl', { alpha: true, depth: true });
    var vertexShaderSource = document.querySelector("#vertexShader").text;
    var fragmentShaderSource = document.querySelector("#fragmentShader").text;

    class ConstantBuffer {
        constructor(gl, type, data, usage, attribLoc, attribType, attribByteLen) {
            this.gl = gl;
            this.type = type;
            this.data = data;
            this.usage = usage;

            this.attribType = attribType;
            this.attribByteLen = attribByteLen;
            this.attribLoc = attribLoc

            this.buffer = gl.createBuffer();
            gl.bindBuffer(type, this.buffer);
            gl.bufferData(type, data, usage);
        }

        // why the fuck are there no destructors in javascript
        Destroy() {
            gl.deleteBuffer(this.buffer);
            // gl.disableVertexAttribArray(this.attribLoc);
        }

        Bind() {
            gl.bindBuffer(this.type, this.buffer);
            if (this.attribType) this.EnableInputLayout();
        }

        EnableInputLayout() {
            gl.vertexAttribPointer(this.attribLoc, this.attribByteLen, this.attribType, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc);
        }

        DisableInputLayout() {
            gl.disableVertexAttribArray(this.attribLoc);
        }
    }

    class ShaderProgram {
        constructor(gl, vsSource, fsSource) {
            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            };

            function createProgram(gl, vsSource, fsSource) {
                var vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
                var fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

                if (vs && fs) {
                    var program = gl.createProgram();
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);

                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.warn("Could not	link program: " + gl.getProgramInfoLog(program));
                        return null;
                    }
                    return program;
                }
                return null;
            };

            this.gl = gl;
            this.program = createProgram(gl, vsSource, fsSource);
        }

        Destroy() {
            var shaders = this.gl.getAttachedShaders(this.program);
            for (var i = 0; i < shaders.length; ++i) {
                var shader = shaders[i];
                gl.detachShader(this.program, shader);
                gl.deleteShader(shader);
            }
            gl.deleteProgram(this.shaderProgram);
        }

        GetAttrLoc(attrName) {
            return this.gl.getAttribLocation(this.program, attrName);
        }

        SetActive(bActive) {
            if (bActive) {
                this.gl.useProgram(this.program)
            } else {
                console.log("Not yet implemented");
            }
        }
    }


    // depth
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.DEPTH_TEST);
    gl.clearDepth(1.0);
    gl.depthMask(true);

    // color
    gl.clearColor(0.0, 0.0, 0.0, 0.0);
    gl.colorMask(true, true, true, true);

    // viewport
    gl.viewport(0, 0, canvas.width, canvas.height);

    // shader program
    var shaderProgram = new ShaderProgram(gl, vertexShaderSource, fragmentShaderSource);
    shaderProgram.SetActive(true);

    // vertex buffer
    var vertices = [
        -0.4, 0.0,
        0.0, 0.3,
        0.4, 0.0,
    ];
    var posBuffer = new ConstantBuffer(gl,
        gl.ARRAY_BUFFER,
        new Float32Array(vertices),
        gl.STATIC_DRAW,
        shaderProgram.GetAttrLoc("pos"),
        gl.FLOAT, 2);

    var colors = [
        1.0, 0.2, 0.2,
        1.0, 0.2, 0.2,
        1.0, 0.2, 0.2
    ];
    var colBuffer = new ConstantBuffer(gl,
        gl.ARRAY_BUFFER,
        new Float32Array(colors),
        gl.STATIC_DRAW,
        shaderProgram.GetAttrLoc("color"),
        gl.FLOAT, 3);


    // index buffer
    var indices = [0, 1, 2];
    var indexBuffer = new ConstantBuffer(gl,
        gl.ELEMENT_ARRAY_BUFFER,
        new Uint16Array(indices),
        gl.STATIC_DRAW);

    function init() {
        // depth
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.DEPTH_TEST);
        gl.clearDepth(1.0);
        gl.depthMask(true);

        // color
        gl.clearColor(0.2, 0.7, 0.3, 1.0);
        gl.colorMask(true, true, true, true);

        // viewport
        gl.viewport(0, 0, canvas.width, canvas.height);
    };

    function update() {

    };

    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


        // this needs to be per-object
        posBuffer.Bind();
        colBuffer.Bind();
        indexBuffer.Bind();
        gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);
    };

    (function main() {
        init();

        (function animate() {
            update();
            render();
            requestAnimationFrame(animate);
        })();
    })();


    // shutdown
    // {
    //     // release buffers
    //     posBuffer.Destroy();
    //     indexBuffer.Destroy();
    //     shaderProgram.Destroy();
    // }

</script>