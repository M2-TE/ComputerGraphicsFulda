<!doctype html>
<html lang="en">

<body>
    <canvas id="c" width="400" height="400"></canvas>
</body>

</html>

<script id="vertexShader" type="notjs">
    attribute vec4 pos;
    attribute vec3 color;
    uniform vec4 mandatoryUniformForTheTaskThatIDontActuallyNeedButHereItIsAnwaysSoHowLongCanVariableNamesBeAnywaysAhISeeWayTooLongThen;
    varying vec3 vColor;
    void main() {
        vColor = color;
        gl_Position = vec4(pos);
    }
</script>

<script id="fragmentShader" type="notjs">
    #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision	highp float;
    #else
        precision	mediump float;
    #endif

    varying vec3 vColor;
    void main() {
        gl_FragColor = vec4(vColor, 1.0);
    }
</script>

<script>
    class ConstantBuffer {
        constructor(gl, type, data, usage, attribLoc, attribType, attribLen) {
            this.gl = gl;
            this.type = type;
            this.data = data;
            this.usage = usage;

            this.attribType = attribType;
            this.attribLen = attribLen;
            this.attribLoc = attribLoc

            this.buffer = gl.createBuffer();
            this.Update(type, data, usage);
        }

        // why the fuck are there no destructors in javascript
        Destroy() {
            gl.deleteBuffer(this.buffer);
        }

        Update(type, data, usage) {
            gl.bindBuffer(type, this.buffer);
            gl.bufferData(type, data, usage);
        }

        Bind() {
            gl.bindBuffer(this.type, this.buffer);
            if (this.attribType) this.EnableInputLayout();
        }

        EnableInputLayout() {
            gl.vertexAttribPointer(this.attribLoc, this.attribLen, this.attribType, false, 0, 0);
            gl.enableVertexAttribArray(this.attribLoc);
        }

        DisableInputLayout() {
            gl.disableVertexAttribArray(this.attribLoc);
        }
    }

    class ShaderProgram {
        constructor(gl, vsSource, fsSource) {
            function createShader(gl, type, source) {
                var shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                return shader;
            };

            function createProgram(gl, vsSource, fsSource) {
                var vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
                var fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);

                if (vs && fs) {
                    var program = gl.createProgram();
                    gl.attachShader(program, vs);
                    gl.attachShader(program, fs);
                    gl.linkProgram(program);

                    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                        console.warn("Could not	link program: " + gl.getProgramInfoLog(program));
                        return null;
                    }
                    return program;
                }
                return null;
            };

            this.gl = gl;
            this.program = createProgram(gl, vsSource, fsSource);
        }

        Destroy() {
            var shaders = this.gl.getAttachedShaders(this.program);
            for (var i = 0; i < shaders.length; ++i) {
                var shader = shaders[i];
                gl.detachShader(this.program, shader);
                gl.deleteShader(shader);
            }
            gl.deleteProgram(this.shaderProgram);
        }

        GetAttrLoc(attrName) {
            return this.gl.getAttribLocation(this.program, attrName);
        }

        SetActive(bActive) {
            if (bActive) {
                this.gl.useProgram(this.program)
            } else {
                console.log("Not yet implemented");
                // is deactivation necessary for these? 
                // will see later on i spose
            }
        }
    }

    class GameObject {
        constructor(gl, vertices, colors, indices) {
            this.gl = gl;
            this.posBuffer = new ConstantBuffer(gl,
                gl.ARRAY_BUFFER,
                new Float32Array(vertices),
                gl.STATIC_DRAW,
                0, // "pos"
                gl.FLOAT, 2);

            this.colBuffer = new ConstantBuffer(gl,
                gl.ARRAY_BUFFER,
                new Float32Array(colors),
                gl.STATIC_DRAW,
                1, // "color"
                gl.FLOAT, 3);

            this.indexBuffer = new ConstantBuffer(gl,
                gl.ELEMENT_ARRAY_BUFFER,
                new Uint16Array(indices),
                gl.STATIC_DRAW);

            this.indexCount = indices.length;
        }

        Destroy() {
            this.posBuffer.Destroy();
            this.colBuffer.Destroy();
            this.indexBuffer.Destroy();
        }

        Draw() {
            this.posBuffer.Bind();
            this.colBuffer.Bind();
            this.indexBuffer.Bind();
            gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
        }
    }

    function init() {
        var canvas = document.getElementById('c');
        gl = canvas.getContext('webgl', { alpha: true, depth: true });

        // shader program
        shaderProgram = new ShaderProgram(gl,
            document.querySelector("#vertexShader").text,
            document.querySelector("#fragmentShader").text);
        shaderProgram.SetActive(true);

        // depth
        gl.depthFunc(gl.LEQUAL);
        gl.enable(gl.DEPTH_TEST);
        gl.clearDepth(1.0);
        gl.depthMask(true);

        // color
        gl.clearColor(0.3, 0.7, 0.3, 1.0);
        gl.colorMask(true, true, true, true);

        // viewport
        gl.viewport(0, 0, canvas.width, canvas.height);

        // game objects
        gameObjects = [];
        /* 
        * currently using a per-object-buffer setup
        * with static_draw buffer usage. Depending on future tasks,
        * this can be changed to creating 3 global buffers for pos, col and indices
        * which each object uploads its data to on every draw call
        * -> dynamic buffer usage
        */

        // roof
        {
            var vertices = [
                -0.4, 0.0,
                0.0, 0.3,
                0.4, 0.0,];
            var colors = [
                1.0, 0.2, 0.2,
                1.0, 0.2, 0.2,
                1.0, 0.2, 0.2];
            var indices = [0, 1, 2];
            gameObjects.push(new GameObject(gl, vertices, colors, indices));
        }

        // house base
        {
            var vertices = [
                -0.35, 0.0,
                0.35, 0.0,
                0.35, -0.5,
                -0.35, -0.5];
            var colors = [
                1.0, 0.9, 0.9,
                1.0, 0.9, 0.9,
                1.0, 0.9, 0.9,
                1.0, 0.9, 0.9];
            var indices = [0, 1, 2, /**/ 0, 2, 3];
            gameObjects.push(new GameObject(gl, vertices, colors, indices));
        }
    };

    function update() {
        // TODO
    };

    function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        for (var i = 0; i < gameObjects.length; ++i) {
            gameObjects[i].Draw();
        }
    };

    function shutdown() {
        {
            // release resources
            for (var i = 0; i < gameObjects.length; ++i) {
                gameObjects[i].Destroy();
            }
            shaderProgram.Destroy();
        }
    };

    main();
    function main() {
        var gl;
        var gameObjects;
        var shaderProgram;

        init();

        var lastFrameTimestamp = 0;
        var deltaTime = 0;
        var frameRate = 0;

        // initiate frame pass loop
        renderLoop(0);
        function renderLoop(time) {
            deltaTime = (time *= 0.001) - lastFrameTimestamp;
            lastFrameTimestamp = time;
            framerate = 1.0 / deltaTime;

            //console.log(framerate);
            //console.log(deltaTime);

            update();
            render();
            requestAnimationFrame(renderLoop);
        };

        // shutdown();
    };
</script>